---
layout: post
title: ROS
---


# Pense-bête pour ROS
## Se simplifier la vie
- Utiliser zsh (bash amélioré permettant notamment de naviguer entre les résultats de l'autocomplétion, de réaliser des complétions automatiques à l'aide de l'historique,...). Après avoir installé zsh, il faut le définir comme interpréteur par défaut du système avec ```chsh``` en lui entrant ```/usr/bin/zsh``` (cela s'applique pour l'utilisateur l'appelant => comportement différents entre "chsh" et "sudo chsh"). Une re-connexion ou un re-démarrage de l'ordinateur sera nécessaire. 
- Utiliser [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh) en complément de zsh, il s'installe très facilement à l'aide de la commande invoquant curl ou wget dans le readme du projet. Ce paquet permet d'utiliser des thèmes ayant des fonctionnalités partiques (telle que l'intégration git, affichant le nom de la branche et si le dépôt est à à jour...). J'ai une légère préférence pour le thème "agnoster" et son apparence de type powerline.
- Sourcer le workspace à l'ouverture du terminal (ajouter la ligne ```source <ros_workspace_folder>/devel/setup.zsh``` au fichier .zshrc - cela peut s'applique aussi pour bash avec ```source <ros_workspace_folder>/devel/setup.zsh``` dans le .bashrc).
- Créer un/des alias permettant de compiler et sourcer facilement le workspace de n'importe où en ajoutant les entrées suivantes dans le bashrc et/ou zshrc (j'ai choisi des touches doublées pour pas se poser de questions et ces dernières sont proches de mes doigts : rr et tt) :

      alias tt="cd ~/<ros_workspace_folder> && catkin_make && source ~/<ros_workspace_folder>/devel/setup.zsh"
      alias rr="source ~/<ros_workspace_folder>/devel/setup.zsh"

Attention à bien mettre des chemins absolus afin de pouvoir appeler les commandes de n'importe où et de changer les commandes pour bash (les extensions ".zsh" doivent devenir ".bash").


## L'incontournable
- La variable environnementale [ROS_MASTER_URI](http://wiki.ros.org/ROS/Tutorials/MultipleMachines). Cette variable permet de localiser un roscore sur un réseau local. Cela permet donc de distribuer une architecture logicielle sur un réseau (grand intérêt du middleware), afin notamment de superviser un programme à distance, de le débugger ou encore de distribuer des programmes gourmands sur une autre machine. Il suffit de taper : ```export ROS_MASTER_URI=http://<ip_roscore>:11311``` et de lancer les noeuds ou launchfiles via unhttp://wiki.ros.org/ROS/Tutorials/MultipleMachines roslaunch (qui détectera le roscore automatiquement). Un diagnostique rapide du fonctionnement peut être réalisé en lançant ```rqt```, car il requiert un roscore pour fonctionner. Donc s'il se lance correctement on a une preuve que cela fonctionne. Attention à bien vérifier que le pare-feux permet cet échange (pour les utilisateurs de "gufw" par exemple). Pour désactiver cette fonctionnalité, il suffit de supprimer la variable à l'aide de : ```unset ROS_MASTER_URI```


## Diagnostiquer de potentiels problèmes
- De temps en temps, il faut supprimer les dossiers "build" et "devel" qui sont dans le workspace, afin de re-compiler le/les projets de zéro et diagnostiquer des problèmes potentiels.
- La commande [roswtf](http://wiki.ros.org/roswtf) permet de diagnostiquer de potentiels problèmes lorsque l'étape précédente est validée. Cette commande vérifie la cohérence des paquets (mauvaises dépendances,...) et se lance sur un launchfile.


## Les packets à connaître absolument
- [robot-upstart](http://wiki.ros.org/robot_upstart) : permet de générer automatiquement un service (compatible systemd) démarrant le programme au démarage de la machine [http://docs.ros.org/jade/api/robot_upstart/html/](http://docs.ros.org/jade/api/robot_upstart/html/).
- [timed-roslaunch](http://wiki.ros.org/timed_roslaunch) : permet de temporiser le démarage d'un roslaunch.
